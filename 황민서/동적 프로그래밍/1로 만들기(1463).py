# 마찬가지로 바텀업 방식으로 푼 문제
# 3으로 나누기, 2로 나누기, 1빼기 3가지 경우가 있는데
# dp 리스트의 인덱스를 활용하여, i/2일 경우 + 1, i/3일 경우 + 1, i-1일 경우+1을 모두 비교해서
# 최솟값을 dp[i]에 저장하게 되면 그게 i를 사용해 1을 만들기 위해 필요한 연산 수의 최솟값일 것이다.
# 세가지 경우를 비교하는 것을 구현하는게 가장 시간이 많이 들었음.

n = int(input())
dp = [0] * (n+1)


for i in range(2, n+1):
    dp[i] = dp[i-1] + 1
    if i % 3 == 0:
        dp[i] = min(dp[i//3] + 1, dp[i])
    if i % 2 == 0:
        dp[i] = min(dp[i//2] + 1, dp[i])

print(dp[n])
